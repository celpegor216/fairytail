{"ast":null,"code":"import { BufferAttribute, BufferGeometry, Float32BufferAttribute, InstancedBufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, Vector3 } from 'three';\nfunction computeTangents() {\n  throw new Error('BufferGeometryUtils: computeTangents renamed to computeMikkTSpaceTangents.');\n}\nfunction computeMikkTSpaceTangents(geometry, MikkTSpace) {\n  var negateSign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (!MikkTSpace || !MikkTSpace.isReady) {\n    throw new Error('BufferGeometryUtils: Initialized MikkTSpace library required.');\n  }\n  if (!geometry.hasAttribute('position') || !geometry.hasAttribute('normal') || !geometry.hasAttribute('uv')) {\n    throw new Error('BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.');\n  }\n  function getAttributeArray(attribute) {\n    if (attribute.normalized || attribute.isInterleavedBufferAttribute) {\n      var dstArray = new Float32Array(attribute.getCount() * attribute.itemSize);\n      for (var i = 0, j = 0; i < attribute.getCount(); i++) {\n        dstArray[j++] = attribute.getX(i);\n        dstArray[j++] = attribute.getY(i);\n        if (attribute.itemSize > 2) {\n          dstArray[j++] = attribute.getZ(i);\n        }\n      }\n      return dstArray;\n    }\n    if (attribute.array instanceof Float32Array) {\n      return attribute.array;\n    }\n    return new Float32Array(attribute.array);\n  }\n\n  // MikkTSpace algorithm requires non-indexed input.\n\n  var _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n  // Compute vertex tangents.\n\n  var tangents = MikkTSpace.generateTangents(getAttributeArray(_geometry.attributes.position), getAttributeArray(_geometry.attributes.normal), getAttributeArray(_geometry.attributes.uv));\n\n  // Texture coordinate convention of glTF differs from the apparent\n  // default of the MikkTSpace library; .w component must be flipped.\n\n  if (negateSign) {\n    for (var i = 3; i < tangents.length; i += 4) {\n      tangents[i] *= -1;\n    }\n  }\n\n  //\n\n  _geometry.setAttribute('tangent', new BufferAttribute(tangents, 4));\n  if (geometry !== _geometry) {\n    geometry.copy(_geometry);\n  }\n  return geometry;\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeBufferGeometries(geometries) {\n  var useGroups = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var isIndexed = geometries[0].index !== null;\n  var attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  var morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  var attributes = {};\n  var morphAttributes = {};\n  var morphTargetsRelative = geometries[0].morphTargetsRelative;\n  var mergedGeometry = new BufferGeometry();\n  var offset = 0;\n  for (var i = 0; i < geometries.length; ++i) {\n    var geometry = geometries[i];\n    var attributesCount = 0;\n\n    // ensure that all geometries are indexed, or none\n\n    if (isIndexed !== (geometry.index !== null)) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n      return null;\n    }\n\n    // gather attributes, exit early if they're different\n\n    for (var name in geometry.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n        return null;\n      }\n      if (attributes[name] === undefined) attributes[name] = [];\n      attributes[name].push(geometry.attributes[name]);\n      attributesCount++;\n    }\n\n    // ensure geometries have the same number of attributes\n\n    if (attributesCount !== attributesUsed.size) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');\n      return null;\n    }\n\n    // gather morph attributes, exit early if they're different\n\n    if (morphTargetsRelative !== geometry.morphTargetsRelative) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');\n      return null;\n    }\n    for (var _name in geometry.morphAttributes) {\n      if (!morphAttributesUsed.has(_name)) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');\n        return null;\n      }\n      if (morphAttributes[_name] === undefined) morphAttributes[_name] = [];\n      morphAttributes[_name].push(geometry.morphAttributes[_name]);\n    }\n    if (useGroups) {\n      var count = void 0;\n      if (isIndexed) {\n        count = geometry.index.count;\n      } else if (geometry.attributes.position !== undefined) {\n        count = geometry.attributes.position.count;\n      } else {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  }\n\n  // merge indices\n\n  if (isIndexed) {\n    var indexOffset = 0;\n    var mergedIndex = [];\n    for (var _i = 0; _i < geometries.length; ++_i) {\n      var index = geometries[_i].index;\n      for (var j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geometries[_i].attributes.position.count;\n    }\n    mergedGeometry.setIndex(mergedIndex);\n  }\n\n  // merge attributes\n\n  for (var _name2 in attributes) {\n    var mergedAttribute = mergeBufferAttributes(attributes[_name2]);\n    if (!mergedAttribute) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + _name2 + ' attribute.');\n      return null;\n    }\n    mergedGeometry.setAttribute(_name2, mergedAttribute);\n  }\n\n  // merge morph attributes\n\n  for (var _name3 in morphAttributes) {\n    var numMorphTargets = morphAttributes[_name3][0].length;\n    if (numMorphTargets === 0) break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[_name3] = [];\n    for (var _i2 = 0; _i2 < numMorphTargets; ++_i2) {\n      var morphAttributesToMerge = [];\n      for (var _j = 0; _j < morphAttributes[_name3].length; ++_j) {\n        morphAttributesToMerge.push(morphAttributes[_name3][_j][_i2]);\n      }\n      var mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + _name3 + ' morphAttribute.');\n        return null;\n      }\n      mergedGeometry.morphAttributes[_name3].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeBufferAttributes(attributes) {\n  var TypedArray;\n  var itemSize;\n  var normalized;\n  var arrayLength = 0;\n  for (var i = 0; i < attributes.length; ++i) {\n    var attribute = attributes[i];\n    if (attribute.isInterleavedBufferAttribute) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.');\n      return null;\n    }\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');\n      return null;\n    }\n    if (itemSize === undefined) itemSize = attribute.itemSize;\n    if (itemSize !== attribute.itemSize) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');\n      return null;\n    }\n    if (normalized === undefined) normalized = attribute.normalized;\n    if (normalized !== attribute.normalized) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');\n      return null;\n    }\n    arrayLength += attribute.array.length;\n  }\n  var array = new TypedArray(arrayLength);\n  var offset = 0;\n  for (var _i3 = 0; _i3 < attributes.length; ++_i3) {\n    array.set(attributes[_i3].array, offset);\n    offset += attributes[_i3].array.length;\n  }\n  return new BufferAttribute(array, itemSize, normalized);\n}\n\n/**\n * @param {BufferAttribute}\n * @return {BufferAttribute}\n */\nexport function deepCloneAttribute(attribute) {\n  if (attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute) {\n    return deinterleaveAttribute(attribute);\n  }\n  if (attribute.isInstancedBufferAttribute) {\n    return new InstancedBufferAttribute().copy(attribute);\n  }\n  return new BufferAttribute().copy(attribute);\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes(attributes) {\n  // Interleaves the provided attributes into an InterleavedBuffer and returns\n  // a set of InterleavedBufferAttributes for each attribute\n  var TypedArray;\n  var arrayLength = 0;\n  var stride = 0;\n\n  // calculate the length and type of the interleavedBuffer\n  for (var i = 0, l = attributes.length; i < l; ++i) {\n    var attribute = attributes[i];\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('AttributeBuffers of different types cannot be interleaved');\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n\n  // Create the set of buffer attributes\n  var interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n  var offset = 0;\n  var res = [];\n  var getters = ['getX', 'getY', 'getZ', 'getW'];\n  var setters = ['setX', 'setY', 'setZ', 'setW'];\n  for (var j = 0, _l = attributes.length; j < _l; j++) {\n    var _attribute = attributes[j];\n    var itemSize = _attribute.itemSize;\n    var count = _attribute.count;\n    var iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, _attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n\n    // Move the data for each attribute into the new interleavedBuffer\n    // at the appropriate offset\n    for (var c = 0; c < count; c++) {\n      for (var k = 0; k < itemSize; k++) {\n        iba[setters[k]](c, _attribute[getters[k]](c));\n      }\n    }\n  }\n  return res;\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute(attribute) {\n  var cons = attribute.data.array.constructor;\n  var count = attribute.count;\n  var itemSize = attribute.itemSize;\n  var normalized = attribute.normalized;\n  var array = new cons(count * itemSize);\n  var newAttribute;\n  if (attribute.isInstancedInterleavedBufferAttribute) {\n    newAttribute = new InstancedBufferAttribute(array, itemSize, normalized, attribute.meshPerAttribute);\n  } else {\n    newAttribute = new BufferAttribute(array, itemSize, normalized);\n  }\n  for (var i = 0; i < count; i++) {\n    newAttribute.setX(i, attribute.getX(i));\n    if (itemSize >= 2) {\n      newAttribute.setY(i, attribute.getY(i));\n    }\n    if (itemSize >= 3) {\n      newAttribute.setZ(i, attribute.getZ(i));\n    }\n    if (itemSize >= 4) {\n      newAttribute.setW(i, attribute.getW(i));\n    }\n  }\n  return newAttribute;\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry(geometry) {\n  var attributes = geometry.attributes;\n  var morphTargets = geometry.morphTargets;\n  var attrMap = new Map();\n  for (var key in attributes) {\n    var attr = attributes[key];\n    if (attr.isInterleavedBufferAttribute) {\n      if (!attrMap.has(attr)) {\n        attrMap.set(attr, deinterleaveAttribute(attr));\n      }\n      attributes[key] = attrMap.get(attr);\n    }\n  }\n  for (var _key in morphTargets) {\n    var _attr = morphTargets[_key];\n    if (_attr.isInterleavedBufferAttribute) {\n      if (!attrMap.has(_attr)) {\n        attrMap.set(_attr, deinterleaveAttribute(_attr));\n      }\n      morphTargets[_key] = attrMap.get(_attr);\n    }\n  }\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nfunction estimateBytesUsed(geometry) {\n  // Return the estimated memory used by this geometry in bytes\n  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n  // for InterleavedBufferAttributes.\n  var mem = 0;\n  for (var name in geometry.attributes) {\n    var attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  var indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */\nfunction mergeVertices(geometry) {\n  var tolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-4;\n  tolerance = Math.max(tolerance, Number.EPSILON);\n\n  // Generate an index buffer if the geometry doesn't have one, or optimize it\n  // if it's already available.\n  var hashToIndex = {};\n  var indices = geometry.getIndex();\n  var positions = geometry.getAttribute('position');\n  var vertexCount = indices ? indices.count : positions.count;\n\n  // next value for triangle indices\n  var nextIndex = 0;\n\n  // attributes and new attribute arrays\n  var attributeNames = Object.keys(geometry.attributes);\n  var tmpAttributes = {};\n  var tmpMorphAttributes = {};\n  var newIndices = [];\n  var getters = ['getX', 'getY', 'getZ', 'getW'];\n  var setters = ['setX', 'setY', 'setZ', 'setW'];\n\n  // Initialize the arrays, allocating space conservatively. Extra\n  // space will be trimmed in the last step.\n  for (var i = 0, l = attributeNames.length; i < l; i++) {\n    var name = attributeNames[i];\n    var attr = geometry.attributes[name];\n    tmpAttributes[name] = new BufferAttribute(new attr.array.constructor(attr.count * attr.itemSize), attr.itemSize, attr.normalized);\n    var morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      tmpMorphAttributes[name] = new BufferAttribute(new morphAttr.array.constructor(morphAttr.count * morphAttr.itemSize), morphAttr.itemSize, morphAttr.normalized);\n    }\n  }\n\n  // convert the error tolerance to an amount of decimal places to truncate to\n  var decimalShift = Math.log10(1 / tolerance);\n  var shiftMultiplier = Math.pow(10, decimalShift);\n  for (var _i4 = 0; _i4 < vertexCount; _i4++) {\n    var index = indices ? indices.getX(_i4) : _i4;\n\n    // Generate a hash for the vertex attributes at the current index 'i'\n    var hash = '';\n    for (var j = 0, _l2 = attributeNames.length; j < _l2; j++) {\n      var _name4 = attributeNames[j];\n      var attribute = geometry.getAttribute(_name4);\n      var itemSize = attribute.itemSize;\n      for (var k = 0; k < itemSize; k++) {\n        // double tilde truncates the decimal value\n        hash += \"\".concat(~~(attribute[getters[k]](index) * shiftMultiplier), \",\");\n      }\n    }\n\n    // Add another reference to the vertex if it's already\n    // used by another index\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      // copy data to the new index in the temporary attributes\n      for (var _j2 = 0, _l3 = attributeNames.length; _j2 < _l3; _j2++) {\n        var _name5 = attributeNames[_j2];\n        var _attribute2 = geometry.getAttribute(_name5);\n        var _morphAttr = geometry.morphAttributes[_name5];\n        var _itemSize = _attribute2.itemSize;\n        var newarray = tmpAttributes[_name5];\n        var newMorphArrays = tmpMorphAttributes[_name5];\n        for (var _k = 0; _k < _itemSize; _k++) {\n          var getterFunc = getters[_k];\n          var setterFunc = setters[_k];\n          newarray[setterFunc](nextIndex, _attribute2[getterFunc](index));\n          if (_morphAttr) {\n            for (var m = 0, ml = _morphAttr.length; m < ml; m++) {\n              newMorphArrays[m][setterFunc](nextIndex, _morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n\n  // generate result BufferGeometry\n  var result = geometry.clone();\n  for (var _name6 in geometry.attributes) {\n    var tmpAttribute = tmpAttributes[_name6];\n    result.setAttribute(_name6, new BufferAttribute(tmpAttribute.array.slice(0, nextIndex * tmpAttribute.itemSize), tmpAttribute.itemSize, tmpAttribute.normalized));\n    if (!(_name6 in tmpMorphAttributes)) continue;\n    for (var _j3 = 0; _j3 < tmpMorphAttributes[_name6].length; _j3++) {\n      var tmpMorphAttribute = tmpMorphAttributes[_name6][_j3];\n      result.morphAttributes[_name6][_j3] = new BufferAttribute(tmpMorphAttribute.array.slice(0, nextIndex * tmpMorphAttribute.itemSize), tmpMorphAttribute.itemSize, tmpMorphAttribute.normalized);\n    }\n  }\n\n  // indices\n\n  result.setIndex(newIndices);\n  return result;\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');\n    return geometry;\n  }\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    var index = geometry.getIndex();\n\n    // generate index if not present\n\n    if (index === null) {\n      var indices = [];\n      var position = geometry.getAttribute('position');\n      if (position !== undefined) {\n        for (var i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n        return geometry;\n      }\n    }\n\n    //\n\n    var numberOfTriangles = index.count - 2;\n    var newIndices = [];\n    if (drawMode === TriangleFanDrawMode) {\n      // gl.TRIANGLE_FAN\n\n      for (var _i5 = 1; _i5 <= numberOfTriangles; _i5++) {\n        newIndices.push(index.getX(0));\n        newIndices.push(index.getX(_i5));\n        newIndices.push(index.getX(_i5 + 1));\n      }\n    } else {\n      // gl.TRIANGLE_STRIP\n\n      for (var _i6 = 0; _i6 < numberOfTriangles; _i6++) {\n        if (_i6 % 2 === 0) {\n          newIndices.push(index.getX(_i6));\n          newIndices.push(index.getX(_i6 + 1));\n          newIndices.push(index.getX(_i6 + 2));\n        } else {\n          newIndices.push(index.getX(_i6 + 2));\n          newIndices.push(index.getX(_i6 + 1));\n          newIndices.push(index.getX(_i6));\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n    }\n\n    // build final geometry\n\n    var newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);\n    return geometry;\n  }\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.');\n    return null;\n  }\n  var _vA = new Vector3();\n  var _vB = new Vector3();\n  var _vC = new Vector3();\n  var _tempA = new Vector3();\n  var _tempB = new Vector3();\n  var _tempC = new Vector3();\n  var _morphA = new Vector3();\n  var _morphB = new Vector3();\n  var _morphC = new Vector3();\n  function _calculateMorphedAttributeData(object, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a);\n    _vB.fromBufferAttribute(attribute, b);\n    _vC.fromBufferAttribute(attribute, c);\n    var morphInfluences = object.morphTargetInfluences;\n    if (morphAttribute && morphInfluences) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (var _i7 = 0, _il = morphAttribute.length; _i7 < _il; _i7++) {\n        var influence = morphInfluences[_i7];\n        var morph = morphAttribute[_i7];\n        if (influence === 0) continue;\n        _tempA.fromBufferAttribute(morph, a);\n        _tempB.fromBufferAttribute(morph, b);\n        _tempC.fromBufferAttribute(morph, c);\n        if (morphTargetsRelative) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object.isSkinnedMesh) {\n      object.boneTransform(a, _vA);\n      object.boneTransform(b, _vB);\n      object.boneTransform(c, _vC);\n    }\n    modifiedAttributeArray[a * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c * 3 + 2] = _vC.z;\n  }\n  var geometry = object.geometry;\n  var material = object.material;\n  var a, b, c;\n  var index = geometry.index;\n  var positionAttribute = geometry.attributes.position;\n  var morphPosition = geometry.morphAttributes.position;\n  var morphTargetsRelative = geometry.morphTargetsRelative;\n  var normalAttribute = geometry.attributes.normal;\n  var morphNormal = geometry.morphAttributes.position;\n  var groups = geometry.groups;\n  var drawRange = geometry.drawRange;\n  var i, j, il, jl;\n  var group;\n  var start, end;\n  var modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  var modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    // indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n          _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n        _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  } else {\n    // non-indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n          _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n        _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  }\n  var morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n  var morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute: positionAttribute,\n    normalAttribute: normalAttribute,\n    morphedPositionAttribute: morphedPositionAttribute,\n    morphedNormalAttribute: morphedNormalAttribute\n  };\n}\nfunction mergeGroups(geometry) {\n  if (geometry.groups.length === 0) {\n    console.warn('THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.');\n    return geometry;\n  }\n  var groups = geometry.groups;\n\n  // sort groups by material index\n\n  groups = groups.sort(function (a, b) {\n    if (a.materialIndex !== b.materialIndex) return a.materialIndex - b.materialIndex;\n    return a.start - b.start;\n  });\n\n  // create index for non-indexed geometries\n\n  if (geometry.getIndex() === null) {\n    var positionAttribute = geometry.getAttribute('position');\n    var indices = [];\n    for (var i = 0; i < positionAttribute.count; i += 3) {\n      indices.push(i, i + 1, i + 2);\n    }\n    geometry.setIndex(indices);\n  }\n\n  // sort index\n\n  var index = geometry.getIndex();\n  var newIndices = [];\n  for (var _i8 = 0; _i8 < groups.length; _i8++) {\n    var group = groups[_i8];\n    var groupStart = group.start;\n    var groupLength = groupStart + group.count;\n    for (var j = groupStart; j < groupLength; j++) {\n      newIndices.push(index.getX(j));\n    }\n  }\n  geometry.dispose(); // Required to force buffer recreation\n  geometry.setIndex(newIndices);\n\n  // update groups indices\n\n  var start = 0;\n  for (var _i9 = 0; _i9 < groups.length; _i9++) {\n    var _group = groups[_i9];\n    _group.start = start;\n    start += _group.count;\n  }\n\n  // merge groups\n\n  var currentGroup = groups[0];\n  geometry.groups = [currentGroup];\n  for (var _i10 = 1; _i10 < groups.length; _i10++) {\n    var _group2 = groups[_i10];\n    if (currentGroup.materialIndex === _group2.materialIndex) {\n      currentGroup.count += _group2.count;\n    } else {\n      currentGroup = _group2;\n      geometry.groups.push(currentGroup);\n    }\n  }\n  return geometry;\n}\nexport { computeTangents, computeMikkTSpaceTangents, mergeBufferGeometries, mergeBufferAttributes, interleaveAttributes, estimateBytesUsed, mergeVertices, toTrianglesDrawMode, computeMorphedAttributes, mergeGroups };","map":{"version":3,"names":["BufferAttribute","BufferGeometry","Float32BufferAttribute","InstancedBufferAttribute","InterleavedBuffer","InterleavedBufferAttribute","TriangleFanDrawMode","TriangleStripDrawMode","TrianglesDrawMode","Vector3","computeTangents","Error","computeMikkTSpaceTangents","geometry","MikkTSpace","negateSign","isReady","hasAttribute","getAttributeArray","attribute","normalized","isInterleavedBufferAttribute","dstArray","Float32Array","getCount","itemSize","i","j","getX","getY","getZ","array","_geometry","index","toNonIndexed","tangents","generateTangents","attributes","position","normal","uv","length","setAttribute","copy","mergeBufferGeometries","geometries","useGroups","isIndexed","attributesUsed","Set","Object","keys","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","offset","attributesCount","console","error","name","has","undefined","push","size","count","addGroup","indexOffset","mergedIndex","setIndex","mergedAttribute","mergeBufferAttributes","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","TypedArray","arrayLength","constructor","set","deepCloneAttribute","isInstancedInterleavedBufferAttribute","deinterleaveAttribute","isInstancedBufferAttribute","interleaveAttributes","stride","l","interleavedBuffer","res","getters","setters","iba","c","k","cons","data","newAttribute","meshPerAttribute","setX","setY","setZ","setW","getW","deinterleaveGeometry","morphTargets","attrMap","Map","key","attr","get","estimateBytesUsed","mem","getAttribute","BYTES_PER_ELEMENT","indices","getIndex","mergeVertices","tolerance","Math","max","Number","EPSILON","hashToIndex","positions","vertexCount","nextIndex","attributeNames","tmpAttributes","tmpMorphAttributes","newIndices","morphAttr","decimalShift","log10","shiftMultiplier","pow","hash","newarray","newMorphArrays","getterFunc","setterFunc","m","ml","result","clone","tmpAttribute","slice","tmpMorphAttribute","toTrianglesDrawMode","drawMode","warn","numberOfTriangles","newGeometry","clearGroups","computeMorphedAttributes","object","isBufferGeometry","_vA","_vB","_vC","_tempA","_tempB","_tempC","_morphA","_morphB","_morphC","_calculateMorphedAttributeData","morphAttribute","a","b","modifiedAttributeArray","fromBufferAttribute","morphInfluences","morphTargetInfluences","il","influence","morph","addScaledVector","sub","add","isSkinnedMesh","boneTransform","x","y","z","material","positionAttribute","morphPosition","normalAttribute","morphNormal","groups","drawRange","jl","group","start","end","modifiedPosition","modifiedNormal","Array","isArray","min","morphedPositionAttribute","morphedNormalAttribute","mergeGroups","sort","materialIndex","groupStart","groupLength","dispose","currentGroup"],"sources":["C:/Users/Administrator/Desktop/S07P31C209/frontend/node_modules/three/examples/jsm/utils/BufferGeometryUtils.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\nfunction computeTangents() {\n\n\tthrow new Error( 'BufferGeometryUtils: computeTangents renamed to computeMikkTSpaceTangents.' );\n\n}\n\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst dstArray = new Float32Array( attribute.getCount() * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.getCount(); i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeBufferGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeBufferAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeBufferAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeBufferAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tarray.set( attributes[ i ].array, offset );\n\n\t\toffset += attributes[ i ].array.length;\n\n\t}\n\n\treturn new BufferAttribute( array, itemSize, normalized );\n\n}\n\n/**\n * @param {BufferAttribute}\n * @return {BufferAttribute}\n */\nexport function deepCloneAttribute( attribute ) {\n\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\n\n\t\treturn deinterleaveAttribute( attribute );\n\n\t}\n\n\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\treturn new InstancedBufferAttribute().copy( attribute );\n\n\t}\n\n\treturn new BufferAttribute().copy( attribute );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst tmpAttributes = {};\n\tconst tmpMorphAttributes = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t// Initialize the arrays, allocating space conservatively. Extra\n\t// space will be trimmed in the last step.\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst attr = geometry.attributes[ name ];\n\n\t\ttmpAttributes[ name ] = new BufferAttribute(\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\n\t\t\tattr.itemSize,\n\t\t\tattr.normalized\n\t\t);\n\n\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\tif ( morphAttr ) {\n\n\t\t\ttmpMorphAttributes[ name ] = new BufferAttribute(\n\t\t\t\tnew morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize ),\n\t\t\t\tmorphAttr.itemSize,\n\t\t\t\tmorphAttr.normalized\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst decimalShift = Math.log10( 1 / tolerance );\n\tconst shiftMultiplier = Math.pow( 10, decimalShift );\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the temporary attributes\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newarray = tmpAttributes[ name ];\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tconst setterFunc = setters[ k ];\n\t\t\t\t\tnewarray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// generate result BufferGeometry\n\tconst result = geometry.clone();\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst tmpAttribute = tmpAttributes[ name ];\n\n\t\tresult.setAttribute( name, new BufferAttribute(\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\n\t\t\ttmpAttribute.itemSize,\n\t\t\ttmpAttribute.normalized,\n\t\t) );\n\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\n\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\n\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\n\n\t\t\tresult.morphAttributes[ name ][ j ] = new BufferAttribute(\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\n\t\t\t\ttmpMorphAttribute.itemSize,\n\t\t\t\ttmpMorphAttribute.normalized,\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tif ( object.geometry.isBufferGeometry !== true ) {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.' );\n\t\treturn null;\n\n\t}\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.boneTransform( a, _vA );\n\t\t\tobject.boneTransform( b, _vB );\n\t\t\tobject.boneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\nexport {\n\tcomputeTangents,\n\tcomputeMikkTSpaceTangents,\n\tmergeBufferGeometries,\n\tmergeBufferAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}